## 如何进行类型约束

> 在变量、函数参数、函数返回值位置，加上`:类型`。

```ts
let uname:string;

function test(a: number, b: number): number {
    return a + b;
}
```



> - 基本的类型推导。
>- 编译结果中没有类型约束的代码。



## 基本类型

> - `number`
> - `string`
> - `boolean`
> - `symbol`
> - `bigint`
> - 数组：
>   - `类型[]`，例如：`number[]`
>   - `Array<类型>`，例如：`Array<number>`
> - 对象：`object`，粗略约束为一个对象
> - `null`
> - `undefined`



## 其他常用类型

> - 联合类型：`类型1 | 类型2`，例如：`number | string`
> - `void`类型：通常用于约束函数的返回值，表示该函数**无任何返回值**。
> - `never`类型：通常用于约束函数的返回值，表示该函数**永远不可能结束**。     
> - 字面量类型：使用一个值进行约束。例如：`let gender: 0 | 1;`                                                                                                                                             
> - 元祖类型：一个固定长度的数组，且数组的每一项类型确定。例如：`const arr: [number, string] = [1,''];`
> - `any`：表示任何类型，忽略类型检查。(`any`类型的数据，可以赋值给任何类型的变量)





## 类型别名

> `type 类名名称 = 类型;`

```ts
type User = {
    uname: string;
    gender: 0 | 1;
    age: number;
};
```





## 函数的相关约束

> `function 函数名(函数参数: 类型):类型;`

**函数重载**

```ts
function add(a: number, b: number): number;
function add(a: string, b: string): string;
function add(a: number | string, b: number | string){
    if(typeof a === 'number' && typeof b === 'number'){
        return a * b;
    } else if(typeof a === 'string' && typeof b === 'string') {
        return a + b;
    }
}
```

**可选参数**

```ts
function sum(a: number, b: number, c?: number): number {
    return c ? a + b + c : a + b;
}
```

**默认参数**

```ts
function sum(a: number, b: number, c: number = 0): number {
    return c + a * b
}
```

> 可选参数、默认参数，必须放置在函数参数末尾。



















