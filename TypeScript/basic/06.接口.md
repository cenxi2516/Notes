> 接口用于约束**类**、**对象**、**函数**的标准。（强约束）
>
> 接口可以继承。

## 接口约束对象

### 类型别名约束对象

```ts
type User = {
    name: string;
    age: number;
    sayHello(): void;
};

const user:User = {
    name: 'lsx',
    age: 23,
    sayHello(){}
};
```



### 接口约束对象

```ts
interface User {
    name: string;
    age: 24;
    sayHello: () => void
}

const user: User = {
    name: 'lsx',
    age: 24,
    sayHello(){}
};
```



## 接口约束函数

### 类型别名约束函数

```ts
type ConditionFn = (n:number) => Boolean;

function sum(nums: number[], callback: ConditionFn) {
    let result = 0;
    nums.forEach((value, i) => {
        if(callback(i)){
            result += value;
        }
    });
    
    return result;
}
```



### 接口约束函数

```ts
interface ConditionFn {
    (n: number): boolean
}

function sum(nums: number[], callback: ConditionFn) {
    let result = 0;
    nums.forEach((value, i) => {
        if(callback(i)){
            result += value;
        }
    });
    
    return result;
}
```





## 接口继承

> - 接口可以多继承。
> - 子接口不能覆盖父接口的成员。

```ts
enum Gender {
	male = 0,
    female = 1
}

interface Person {
    name: string;
    gender: Gender,
}

interface Student extends Person {
    noId: string
}
```



## 类型别名组合

> - 通过`&`，实现类型别名的组合。
> - 类型别名间相同的类型约束会交叉。

```ts
enum Gender {
	male = 0,
    female = 1
}

type Person = {
    name: string;
    gender: Gender;
};

type Student = {
    noId: string
} & Person;
```



## 修饰符

> - `readonly`：只读。
> - `?`：可选

```ts
interface User {
    readonly id: string; // 对象的id属性，在开发时是只读的，不能重新赋值
    name: string;
    age: number;
}
```



### 只读数组

> - 只读数组：不能对数组进行增、删、改、查操作。
> - 仅限于编译阶段。

```ts
const arr: readonly number[] = [1, 2, 3];
// 或者
const arr: Readonly<number> = [1, 2, 3];

interface User {
    readonly permissions: readonly number[];
}
```

































