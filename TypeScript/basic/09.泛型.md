> - **泛型**：附属于**函数**、**类**、**接口**、**类型别名**之上的类型。
>
> - 定义时无法知道泛型具体类型，需在使用时传递泛型的具体类型。（泛型类似于**类型变量**）
>
> - 很多时候，未传递泛型的具体类型，会推导泛型的具体类型。
> - 未传递泛型的具体类型，也无法推导泛型的具体类型，泛型类型默认为空对象。
> - 可以设置泛型默认值。

```ts
// 类型变量
// 1、传递泛型具体类型
// 2、推导泛型具体类型
// 3、泛型类型默认为空对象
```

> 定义泛型：`<泛型名称 = 泛型默认类型>`



## 在函数上使用泛型

```ts
function take<T = number>(arr: T[], n: number): T[] {
    const { length } = arr;

    n = Math.min(n, length);
    const result: T[] = [];

    for (let i = 0; i < length; i++) {
        result.push(arr[i]);
    }

    return result;
}

const result1 = take(['1', '3', '5', '4', '6'], 2); //  未传递，会进行类型推导
const result2 = take<number>([1, 3, 2, 4, 6], 2); // 传递具体的类型
```





## 在类型别名、接口、类中使用泛型

### 类型别名中使用泛型

```ts
type callbackFn<T> = (value: T, i: number) => boolean;

function filter<T>(arr: Array<T>, callback: callbackFn<T>): Array<T> {
    const result: Array<T> = [];

    arr.forEach((value, i) => {
        if (callback(value, i)) {
            result.push(value);
        }
    });

    return result;
}

const newArr1 = filter(['1', '3', '5', '4', '6'], Boolean);
const newArr2 = filter<string>(['1', '3', '5', '4', '6'], Boolean);
```



### 接口中使用泛型

```ts
interface callbackFn<T> {
    (value: T, i: number): boolean;
}

function filter<T>(arr: Array<T>, callback: callbackFn<T>): Array<T> {
    const result: Array<T> = [];

    arr.forEach((value, i) => {
        if (callback(value, i)) {
            result.push(value);
        }
    });

    return result;
}

const newArr1 = filter(['1', '3', '5', '4', '6'], Boolean);
const newArr2 = filter<string>(['1', '3', '5', '4', '6'], Boolean);
```



### 类中使用泛型

```ts
class ArrayHelper<T> {
    constructor(private arr: T[]) { }

    take(n: number): T[] {
        const { length } = this.arr;
        n = Math.min(n, length);
        n = Math.max(n, 0);

        const result: T[] = [...this.arr].splice(0, n);

        return result;
    }
}

const arr = new ArrayHelper<number>([1, 2, 3, 4]);
const newArr = arr.take(2);
```





## 泛型约束

> 泛型约束，用于约束泛型的类型。

```ts
interface HasNameProperty {
    name: string;
}

function nameToUpperCase<T extends HasNameProperty>(obj: T): T {
    obj.name = obj.name
        .split(/\s+/)
        .filter(Boolean)
        .map(word => word[0].toUpperCase() + word.slice(1).toLowerCase())
        .join(' ');

    return obj;
}

const obj = {
    name: 'hello world'
};

const result = nameToUpperCase(obj);

console.log(result);

```



## 多泛型

```ts
function mixinArray<T, K>(arr1: Array<T>, arr2: Array<K>): Array<T | K> {
    const newArr: Array<T | K> = [...arr1, ...arr2];

    return newArr;
}

const newArr = mixinArray([1, 2, 3, 4], ['a', 'b', 'c']);
```





























